/* msiextract.c generated by valac 0.20.1, the Vala compiler
 * generated from msiextract.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <libmsi.h>
#include <libgcab.h>
#include <gio/gio.h>
#include <stdio.h>
#include <glib/gi18n-lib.h>
#include <config.h>

#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
typedef struct _Block1Data Block1Data;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_context_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _Block1Data {
	int _ref_count_;
	GHashTable* cab_to_name;
};


extern gboolean version;
gboolean version = FALSE;
extern gboolean list_only;
gboolean list_only = FALSE;
extern gchar** files;
gchar** files = NULL;
extern gchar* directory;
gchar* directory = NULL;

gchar* get_long_name (const gchar* str);
void extract_cab (LibmsiDatabase* db, const gchar* cab, GHashTable* cab_to_name, GError** error);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static gboolean ___lambda2_ (Block1Data* _data1_, GCabFile* current);
static gboolean ____lambda2__gcab_file_callback (GCabFile* file, gpointer self);
gchar* get_directory_name (LibmsiRecord* rec, GError** error);
void extract (const gchar* filename, GError** error);
static void _g_free0_ (gpointer var);
static void _g_object_unref0_ (gpointer var);
gint _vala_main (gchar** args, int args_length1);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);

const GOptionEntry options[5] = {{"version", (gchar) 0, 0, G_OPTION_ARG_NONE, &version, "Display version number", NULL}, {"directory", 'C', 0, G_OPTION_ARG_FILENAME, &directory, "Extract to directory", NULL}, {"list", 'l', 0, G_OPTION_ARG_NONE, &list_only, "List files only", NULL}, {"", (gchar) 0, 0, G_OPTION_ARG_FILENAME_ARRAY, &files, NULL, "MSI_FILE..."}, {NULL}};

gchar* get_long_name (const gchar* str) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	gchar** _tmp1_;
	gchar** _tmp2_ = NULL;
	gchar** names;
	gint names_length1;
	gint _names_size_;
	gchar** _tmp3_;
	gint _tmp3__length1;
	const gchar* _tmp7_;
	gchar* _tmp8_;
	g_return_val_if_fail (str != NULL, NULL);
	_tmp0_ = str;
	_tmp2_ = _tmp1_ = g_strsplit (_tmp0_, "|", 2);
	names = _tmp2_;
	names_length1 = _vala_array_length (_tmp1_);
	_names_size_ = names_length1;
	_tmp3_ = names;
	_tmp3__length1 = names_length1;
	if (_tmp3__length1 == 2) {
		gchar** _tmp4_;
		gint _tmp4__length1;
		const gchar* _tmp5_;
		gchar* _tmp6_;
		_tmp4_ = names;
		_tmp4__length1 = names_length1;
		_tmp5_ = _tmp4_[1];
		_tmp6_ = g_strdup (_tmp5_);
		result = _tmp6_;
		names = (_vala_array_free (names, names_length1, (GDestroyNotify) g_free), NULL);
		return result;
	}
	_tmp7_ = str;
	_tmp8_ = g_strdup (_tmp7_);
	result = _tmp8_;
	names = (_vala_array_free (names, names_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


static gpointer _g_hash_table_ref0 (gpointer self) {
	return self ? g_hash_table_ref (self) : NULL;
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		_g_hash_table_unref0 (_data1_->cab_to_name);
		g_slice_free (Block1Data, _data1_);
	}
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* _tmp0_;
	glong _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* end;
	gchar* _tmp3_;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_;
		gchar* _tmp6_;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_;
	gboolean _tmp3_;
	glong _tmp9_;
	glong _tmp15_;
	glong _tmp18_;
	glong _tmp19_;
	glong _tmp20_;
	glong _tmp21_;
	glong _tmp22_;
	gchar* _tmp23_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		glong _tmp4_;
		glong _tmp5_;
		glong _tmp6_ = 0L;
		_tmp4_ = offset;
		_tmp5_ = len;
		_tmp6_ = string_strnlen ((gchar*) self, _tmp4_ + _tmp5_);
		string_length = _tmp6_;
	} else {
		gint _tmp7_;
		gint _tmp8_;
		_tmp7_ = strlen (self);
		_tmp8_ = _tmp7_;
		string_length = (glong) _tmp8_;
	}
	_tmp9_ = offset;
	if (_tmp9_ < ((glong) 0)) {
		glong _tmp10_;
		glong _tmp11_;
		glong _tmp12_;
		_tmp10_ = string_length;
		_tmp11_ = offset;
		offset = _tmp10_ + _tmp11_;
		_tmp12_ = offset;
		g_return_val_if_fail (_tmp12_ >= ((glong) 0), NULL);
	} else {
		glong _tmp13_;
		glong _tmp14_;
		_tmp13_ = offset;
		_tmp14_ = string_length;
		g_return_val_if_fail (_tmp13_ <= _tmp14_, NULL);
	}
	_tmp15_ = len;
	if (_tmp15_ < ((glong) 0)) {
		glong _tmp16_;
		glong _tmp17_;
		_tmp16_ = string_length;
		_tmp17_ = offset;
		len = _tmp16_ - _tmp17_;
	}
	_tmp18_ = offset;
	_tmp19_ = len;
	_tmp20_ = string_length;
	g_return_val_if_fail ((_tmp18_ + _tmp19_) <= _tmp20_, NULL);
	_tmp21_ = offset;
	_tmp22_ = len;
	_tmp23_ = g_strndup (((gchar*) self) + _tmp21_, (gsize) _tmp22_);
	result = _tmp23_;
	return result;
}


static gboolean ___lambda2_ (Block1Data* _data1_, GCabFile* current) {
	gboolean result = FALSE;
	GHashTable* _tmp0_;
	GCabFile* _tmp1_;
	const gchar* _tmp2_ = NULL;
	gconstpointer _tmp3_ = NULL;
	gchar* _tmp4_;
	gchar* extname;
	const gchar* _tmp5_;
	GCabFile* _tmp10_;
	const gchar* _tmp11_;
	FILE* _tmp12_;
	const gchar* _tmp13_;
	g_return_val_if_fail (current != NULL, FALSE);
	_tmp0_ = _data1_->cab_to_name;
	_tmp1_ = current;
	_tmp2_ = gcab_file_get_name (_tmp1_);
	_tmp3_ = g_hash_table_lookup (_tmp0_, _tmp2_);
	_tmp4_ = g_strdup ((const gchar*) _tmp3_);
	extname = _tmp4_;
	_tmp5_ = extname;
	if (_tmp5_ == NULL) {
		GCabFile* _tmp6_;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_;
		const gchar* _tmp9_;
		_tmp6_ = current;
		_tmp7_ = gcab_file_get_name (_tmp6_);
		_tmp8_ = g_strdup (_tmp7_);
		_g_free0 (extname);
		extname = _tmp8_;
		_tmp9_ = extname;
		g_warning ("msiextract.vala:40: couldn't lookup MSI name, fallback on cab name %s", _tmp9_);
	}
	_tmp10_ = current;
	_tmp11_ = extname;
	gcab_file_set_extract_name (_tmp10_, _tmp11_);
	_tmp12_ = stdout;
	_tmp13_ = extname;
	fprintf (_tmp12_, "%s\n", _tmp13_);
	result = TRUE;
	_g_free0 (extname);
	return result;
}


static gboolean ____lambda2__gcab_file_callback (GCabFile* file, gpointer self) {
	gboolean result;
	result = ___lambda2_ (self, file);
	return result;
}


void extract_cab (LibmsiDatabase* db, const gchar* cab, GHashTable* cab_to_name, GError** error) {
	Block1Data* _data1_;
	GHashTable* _tmp0_;
	GHashTable* _tmp1_;
	const gchar* _tmp2_;
	gboolean _tmp3_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (db != NULL);
	g_return_if_fail (cab != NULL);
	g_return_if_fail (cab_to_name != NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_tmp0_ = cab_to_name;
	_tmp1_ = _g_hash_table_ref0 (_tmp0_);
	_g_hash_table_unref0 (_data1_->cab_to_name);
	_data1_->cab_to_name = _tmp1_;
	_tmp2_ = cab;
	_tmp3_ = g_str_has_prefix (_tmp2_, "#");
	if (_tmp3_) {
		const gchar* _tmp4_;
		gchar* _tmp5_ = NULL;
		gchar* name;
		LibmsiDatabase* _tmp6_;
		const gchar* _tmp7_;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_;
		LibmsiQuery* _tmp10_;
		LibmsiQuery* _tmp11_;
		LibmsiQuery* query;
		LibmsiQuery* _tmp12_;
		LibmsiQuery* _tmp13_;
		LibmsiRecord* _tmp14_ = NULL;
		LibmsiRecord* rec;
		GCabCabinet* _tmp15_;
		GCabCabinet* cabinet;
		GCabCabinet* _tmp16_;
		LibmsiRecord* _tmp17_;
		GInputStream* _tmp18_ = NULL;
		GInputStream* _tmp19_;
		const gchar* _tmp20_;
		GFile* _tmp21_ = NULL;
		GFile* path;
		GCabCabinet* _tmp22_;
		GFile* _tmp23_;
		_tmp4_ = cab;
		_tmp5_ = string_substring (_tmp4_, (glong) 1, (glong) (-1));
		name = _tmp5_;
		_tmp6_ = db;
		_tmp7_ = name;
		_tmp8_ = g_strdup_printf ("SELECT `Data` FROM `_Streams` WHERE `Name` = '%s'", _tmp7_);
		_tmp9_ = _tmp8_;
		_tmp10_ = libmsi_query_new (_tmp6_, _tmp9_, &_inner_error_);
		_tmp11_ = _tmp10_;
		_g_free0 (_tmp9_);
		query = _tmp11_;
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (name);
			block1_data_unref (_data1_);
			_data1_ = NULL;
			return;
		}
		_tmp12_ = query;
		libmsi_query_execute (_tmp12_, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (query);
			_g_free0 (name);
			block1_data_unref (_data1_);
			_data1_ = NULL;
			return;
		}
		_tmp13_ = query;
		_tmp14_ = libmsi_query_fetch (_tmp13_, &_inner_error_);
		rec = _tmp14_;
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (query);
			_g_free0 (name);
			block1_data_unref (_data1_);
			_data1_ = NULL;
			return;
		}
		_tmp15_ = gcab_cabinet_new ();
		cabinet = _tmp15_;
		_tmp16_ = cabinet;
		_tmp17_ = rec;
		_tmp18_ = libmsi_record_get_stream (_tmp17_, (guint) 1);
		_tmp19_ = _tmp18_;
		gcab_cabinet_load (_tmp16_, _tmp19_, NULL, &_inner_error_);
		_g_object_unref0 (_tmp19_);
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (cabinet);
			_g_object_unref0 (rec);
			_g_object_unref0 (query);
			_g_free0 (name);
			block1_data_unref (_data1_);
			_data1_ = NULL;
			return;
		}
		_tmp20_ = directory;
		_tmp21_ = g_file_new_for_path (_tmp20_);
		path = _tmp21_;
		_tmp22_ = cabinet;
		_tmp23_ = path;
		gcab_cabinet_extract_simple (_tmp22_, _tmp23_, ____lambda2__gcab_file_callback, _data1_, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (path);
			_g_object_unref0 (cabinet);
			_g_object_unref0 (rec);
			_g_object_unref0 (query);
			_g_free0 (name);
			block1_data_unref (_data1_);
			_data1_ = NULL;
			return;
		}
		_g_object_unref0 (path);
		_g_object_unref0 (cabinet);
		_g_object_unref0 (rec);
		_g_object_unref0 (query);
		_g_free0 (name);
	}
	block1_data_unref (_data1_);
	_data1_ = NULL;
}


gchar* get_directory_name (LibmsiRecord* rec, GError** error) {
	gchar* result = NULL;
	LibmsiRecord* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	gchar* name;
	LibmsiRecord* _tmp5_;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_;
	gboolean _tmp8_;
	g_return_val_if_fail (rec != NULL, NULL);
	_tmp0_ = rec;
	_tmp1_ = libmsi_record_get_string (_tmp0_, (guint) 3);
	_tmp2_ = _tmp1_;
	_tmp3_ = get_long_name (_tmp2_);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	name = _tmp4_;
	_tmp5_ = rec;
	_tmp6_ = libmsi_record_get_string (_tmp5_, (guint) 1);
	_tmp7_ = _tmp6_;
	_tmp8_ = g_strcmp0 (_tmp7_, "ProgramFilesFolder") == 0;
	_g_free0 (_tmp7_);
	if (_tmp8_) {
		gchar* _tmp9_;
		_tmp9_ = g_strdup ("Program Files");
		result = _tmp9_;
		_g_free0 (name);
		return result;
	} else {
		const gchar* _tmp10_;
		_tmp10_ = name;
		if (g_strcmp0 (_tmp10_, ".") == 0) {
			gchar* _tmp11_;
			_tmp11_ = g_strdup ("");
			result = _tmp11_;
			_g_free0 (name);
			return result;
		} else {
			const gchar* _tmp12_;
			_tmp12_ = name;
			if (g_strcmp0 (_tmp12_, "SourceDir") == 0) {
				result = NULL;
				_g_free0 (name);
				return result;
			}
		}
	}
	result = name;
	return result;
}


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void extract (const gchar* filename, GError** error) {
	LibmsiRecord* rec = NULL;
	const gchar* _tmp0_;
	LibmsiDatabase* _tmp1_;
	LibmsiDatabase* db;
	GHashFunc _tmp2_;
	GEqualFunc _tmp3_;
	GHashTable* _tmp4_;
	GHashTable* directories;
	LibmsiDatabase* _tmp5_;
	LibmsiQuery* _tmp6_;
	LibmsiQuery* query;
	LibmsiQuery* _tmp7_;
	GHashFunc _tmp17_;
	GEqualFunc _tmp18_;
	GHashTable* _tmp19_;
	GHashTable* components_dir;
	LibmsiDatabase* _tmp20_;
	LibmsiQuery* _tmp21_;
	LibmsiQuery* _tmp22_;
	LibmsiQuery* _tmp23_;
	GHashFunc _tmp56_;
	GEqualFunc _tmp57_;
	GHashTable* _tmp58_;
	GHashTable* cab_to_name;
	LibmsiDatabase* _tmp59_;
	LibmsiQuery* _tmp60_;
	LibmsiQuery* _tmp61_;
	LibmsiQuery* _tmp62_;
	gboolean _tmp90_;
	LibmsiDatabase* _tmp91_;
	LibmsiQuery* _tmp92_;
	LibmsiQuery* _tmp93_;
	LibmsiQuery* _tmp94_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (filename != NULL);
	_tmp0_ = filename;
	_tmp1_ = libmsi_database_new (_tmp0_, (guint) LIBMSI_DB_FLAGS_READONLY, NULL, &_inner_error_);
	db = _tmp1_;
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (rec);
		return;
	}
	_tmp2_ = g_str_hash;
	_tmp3_ = g_str_equal;
	_tmp4_ = g_hash_table_new_full (_tmp2_, _tmp3_, _g_free0_, _g_object_unref0_);
	directories = _tmp4_;
	_tmp5_ = db;
	_tmp6_ = libmsi_query_new (_tmp5_, "SELECT * FROM `Directory`", &_inner_error_);
	query = _tmp6_;
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		_g_hash_table_unref0 (directories);
		_g_object_unref0 (db);
		_g_object_unref0 (rec);
		return;
	}
	_tmp7_ = query;
	libmsi_query_execute (_tmp7_, NULL, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (query);
		_g_hash_table_unref0 (directories);
		_g_object_unref0 (db);
		_g_object_unref0 (rec);
		return;
	}
	while (TRUE) {
		LibmsiQuery* _tmp8_;
		LibmsiRecord* _tmp9_ = NULL;
		LibmsiRecord* _tmp10_;
		LibmsiRecord* _tmp11_;
		GHashTable* _tmp12_;
		LibmsiRecord* _tmp13_;
		gchar* _tmp14_ = NULL;
		LibmsiRecord* _tmp15_;
		LibmsiRecord* _tmp16_;
		_tmp8_ = query;
		_tmp9_ = libmsi_query_fetch (_tmp8_, &_inner_error_);
		_tmp10_ = _tmp9_;
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (query);
			_g_hash_table_unref0 (directories);
			_g_object_unref0 (db);
			_g_object_unref0 (rec);
			return;
		}
		_g_object_unref0 (rec);
		rec = _tmp10_;
		_tmp11_ = rec;
		if (!(_tmp11_ != NULL)) {
			break;
		}
		_tmp12_ = directories;
		_tmp13_ = rec;
		_tmp14_ = libmsi_record_get_string (_tmp13_, (guint) 1);
		_tmp15_ = rec;
		_tmp16_ = _g_object_ref0 (_tmp15_);
		g_hash_table_insert (_tmp12_, _tmp14_, _tmp16_);
	}
	_tmp17_ = g_str_hash;
	_tmp18_ = g_str_equal;
	_tmp19_ = g_hash_table_new_full (_tmp17_, _tmp18_, _g_free0_, _g_free0_);
	components_dir = _tmp19_;
	_tmp20_ = db;
	_tmp21_ = libmsi_query_new (_tmp20_, "SELECT * FROM `Component`", &_inner_error_);
	_tmp22_ = _tmp21_;
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		_g_hash_table_unref0 (components_dir);
		_g_object_unref0 (query);
		_g_hash_table_unref0 (directories);
		_g_object_unref0 (db);
		_g_object_unref0 (rec);
		return;
	}
	_g_object_unref0 (query);
	query = _tmp22_;
	_tmp23_ = query;
	libmsi_query_execute (_tmp23_, NULL, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		_g_hash_table_unref0 (components_dir);
		_g_object_unref0 (query);
		_g_hash_table_unref0 (directories);
		_g_object_unref0 (db);
		_g_object_unref0 (rec);
		return;
	}
	while (TRUE) {
		LibmsiQuery* _tmp24_;
		LibmsiRecord* _tmp25_ = NULL;
		LibmsiRecord* _tmp26_;
		LibmsiRecord* _tmp27_;
		LibmsiRecord* _tmp28_;
		gchar* _tmp29_ = NULL;
		gchar* dir_id;
		GHashTable* _tmp30_;
		const gchar* _tmp31_;
		gconstpointer _tmp32_ = NULL;
		LibmsiRecord* _tmp33_;
		LibmsiRecord* dir_rec;
		LibmsiRecord* _tmp34_;
		gchar* _tmp35_ = NULL;
		gchar* dir;
		GHashTable* _tmp51_;
		LibmsiRecord* _tmp52_;
		gchar* _tmp53_ = NULL;
		const gchar* _tmp54_;
		gchar* _tmp55_;
		_tmp24_ = query;
		_tmp25_ = libmsi_query_fetch (_tmp24_, &_inner_error_);
		_tmp26_ = _tmp25_;
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			_g_hash_table_unref0 (components_dir);
			_g_object_unref0 (query);
			_g_hash_table_unref0 (directories);
			_g_object_unref0 (db);
			_g_object_unref0 (rec);
			return;
		}
		_g_object_unref0 (rec);
		rec = _tmp26_;
		_tmp27_ = rec;
		if (!(_tmp27_ != NULL)) {
			break;
		}
		_tmp28_ = rec;
		_tmp29_ = libmsi_record_get_string (_tmp28_, (guint) 3);
		dir_id = _tmp29_;
		_tmp30_ = directories;
		_tmp31_ = dir_id;
		_tmp32_ = g_hash_table_lookup (_tmp30_, _tmp31_);
		_tmp33_ = _g_object_ref0 ((LibmsiRecord*) _tmp32_);
		dir_rec = _tmp33_;
		_tmp34_ = dir_rec;
		_tmp35_ = get_directory_name (_tmp34_, &_inner_error_);
		dir = _tmp35_;
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (dir_rec);
			_g_free0 (dir_id);
			_g_hash_table_unref0 (components_dir);
			_g_object_unref0 (query);
			_g_hash_table_unref0 (directories);
			_g_object_unref0 (db);
			_g_object_unref0 (rec);
			return;
		}
		while (TRUE) {
			LibmsiRecord* _tmp36_;
			gchar* _tmp37_ = NULL;
			gchar* parent;
			GHashTable* _tmp38_;
			const gchar* _tmp39_;
			gconstpointer _tmp40_ = NULL;
			LibmsiRecord* _tmp41_;
			LibmsiRecord* _tmp42_;
			LibmsiRecord* _tmp43_;
			gchar* _tmp44_ = NULL;
			gchar* _tmp45_;
			const gchar* _tmp46_;
			const gchar* _tmp47_;
			const gchar* _tmp48_;
			const gchar* _tmp49_;
			gchar* _tmp50_ = NULL;
			_tmp36_ = dir_rec;
			_tmp37_ = libmsi_record_get_string (_tmp36_, (guint) 2);
			parent = _tmp37_;
			_tmp38_ = directories;
			_tmp39_ = parent;
			_tmp40_ = g_hash_table_lookup (_tmp38_, _tmp39_);
			_tmp41_ = _g_object_ref0 ((LibmsiRecord*) _tmp40_);
			_g_object_unref0 (dir_rec);
			dir_rec = _tmp41_;
			_tmp42_ = dir_rec;
			if (_tmp42_ == NULL) {
				_g_free0 (parent);
				break;
			}
			_tmp43_ = dir_rec;
			_tmp44_ = get_directory_name (_tmp43_, &_inner_error_);
			_tmp45_ = _tmp44_;
			if (_inner_error_ != NULL) {
				g_propagate_error (error, _inner_error_);
				_g_free0 (parent);
				_g_free0 (dir);
				_g_object_unref0 (dir_rec);
				_g_free0 (dir_id);
				_g_hash_table_unref0 (components_dir);
				_g_object_unref0 (query);
				_g_hash_table_unref0 (directories);
				_g_object_unref0 (db);
				_g_object_unref0 (rec);
				return;
			}
			_g_free0 (parent);
			parent = _tmp45_;
			_tmp46_ = parent;
			if (_tmp46_ == NULL) {
				_g_free0 (parent);
				break;
			}
			_tmp47_ = parent;
			if (g_strcmp0 (_tmp47_, "") == 0) {
				_g_free0 (parent);
				continue;
			}
			_tmp48_ = parent;
			_tmp49_ = dir;
			_tmp50_ = g_build_filename (_tmp48_, _tmp49_, NULL);
			_g_free0 (dir);
			dir = _tmp50_;
			_g_free0 (parent);
		}
		_tmp51_ = components_dir;
		_tmp52_ = rec;
		_tmp53_ = libmsi_record_get_string (_tmp52_, (guint) 1);
		_tmp54_ = dir;
		_tmp55_ = g_strdup (_tmp54_);
		g_hash_table_insert (_tmp51_, _tmp53_, _tmp55_);
		_g_free0 (dir);
		_g_object_unref0 (dir_rec);
		_g_free0 (dir_id);
	}
	_tmp56_ = g_str_hash;
	_tmp57_ = g_str_equal;
	_tmp58_ = g_hash_table_new_full (_tmp56_, _tmp57_, _g_free0_, _g_free0_);
	cab_to_name = _tmp58_;
	_tmp59_ = db;
	_tmp60_ = libmsi_query_new (_tmp59_, "SELECT * FROM `File`", &_inner_error_);
	_tmp61_ = _tmp60_;
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		_g_hash_table_unref0 (cab_to_name);
		_g_hash_table_unref0 (components_dir);
		_g_object_unref0 (query);
		_g_hash_table_unref0 (directories);
		_g_object_unref0 (db);
		_g_object_unref0 (rec);
		return;
	}
	_g_object_unref0 (query);
	query = _tmp61_;
	_tmp62_ = query;
	libmsi_query_execute (_tmp62_, NULL, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		_g_hash_table_unref0 (cab_to_name);
		_g_hash_table_unref0 (components_dir);
		_g_object_unref0 (query);
		_g_hash_table_unref0 (directories);
		_g_object_unref0 (db);
		_g_object_unref0 (rec);
		return;
	}
	while (TRUE) {
		LibmsiQuery* _tmp63_;
		LibmsiRecord* _tmp64_ = NULL;
		LibmsiRecord* _tmp65_;
		LibmsiRecord* _tmp66_;
		GHashTable* _tmp67_;
		LibmsiRecord* _tmp68_;
		gchar* _tmp69_ = NULL;
		gchar* _tmp70_;
		gconstpointer _tmp71_ = NULL;
		gchar* _tmp72_;
		gchar* _tmp73_;
		gchar* dir;
		const gchar* _tmp74_;
		LibmsiRecord* _tmp75_;
		gchar* _tmp76_ = NULL;
		gchar* _tmp77_;
		gchar* _tmp78_ = NULL;
		gchar* _tmp79_;
		gchar* _tmp80_ = NULL;
		gchar* _tmp81_;
		gchar* file;
		gboolean _tmp82_;
		GHashTable* _tmp85_;
		LibmsiRecord* _tmp86_;
		gchar* _tmp87_ = NULL;
		const gchar* _tmp88_;
		gchar* _tmp89_;
		_tmp63_ = query;
		_tmp64_ = libmsi_query_fetch (_tmp63_, &_inner_error_);
		_tmp65_ = _tmp64_;
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			_g_hash_table_unref0 (cab_to_name);
			_g_hash_table_unref0 (components_dir);
			_g_object_unref0 (query);
			_g_hash_table_unref0 (directories);
			_g_object_unref0 (db);
			_g_object_unref0 (rec);
			return;
		}
		_g_object_unref0 (rec);
		rec = _tmp65_;
		_tmp66_ = rec;
		if (!(_tmp66_ != NULL)) {
			break;
		}
		_tmp67_ = components_dir;
		_tmp68_ = rec;
		_tmp69_ = libmsi_record_get_string (_tmp68_, (guint) 2);
		_tmp70_ = _tmp69_;
		_tmp71_ = g_hash_table_lookup (_tmp67_, _tmp70_);
		_tmp72_ = g_strdup ((const gchar*) _tmp71_);
		_tmp73_ = _tmp72_;
		_g_free0 (_tmp70_);
		dir = _tmp73_;
		_tmp74_ = dir;
		_tmp75_ = rec;
		_tmp76_ = libmsi_record_get_string (_tmp75_, (guint) 3);
		_tmp77_ = _tmp76_;
		_tmp78_ = get_long_name (_tmp77_);
		_tmp79_ = _tmp78_;
		_tmp80_ = g_build_filename (_tmp74_, _tmp79_, NULL);
		_tmp81_ = _tmp80_;
		_g_free0 (_tmp79_);
		_g_free0 (_tmp77_);
		file = _tmp81_;
		_tmp82_ = list_only;
		if (_tmp82_) {
			FILE* _tmp83_;
			const gchar* _tmp84_;
			_tmp83_ = stdout;
			_tmp84_ = file;
			fprintf (_tmp83_, "%s\n", _tmp84_);
		}
		_tmp85_ = cab_to_name;
		_tmp86_ = rec;
		_tmp87_ = libmsi_record_get_string (_tmp86_, (guint) 1);
		_tmp88_ = file;
		_tmp89_ = g_strdup (_tmp88_);
		g_hash_table_insert (_tmp85_, _tmp87_, _tmp89_);
		_g_free0 (file);
		_g_free0 (dir);
	}
	_tmp90_ = list_only;
	if (_tmp90_) {
		exit (0);
	}
	_tmp91_ = db;
	_tmp92_ = libmsi_query_new (_tmp91_, "SELECT * FROM `Media`", &_inner_error_);
	_tmp93_ = _tmp92_;
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		_g_hash_table_unref0 (cab_to_name);
		_g_hash_table_unref0 (components_dir);
		_g_object_unref0 (query);
		_g_hash_table_unref0 (directories);
		_g_object_unref0 (db);
		_g_object_unref0 (rec);
		return;
	}
	_g_object_unref0 (query);
	query = _tmp93_;
	_tmp94_ = query;
	libmsi_query_execute (_tmp94_, NULL, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		_g_hash_table_unref0 (cab_to_name);
		_g_hash_table_unref0 (components_dir);
		_g_object_unref0 (query);
		_g_hash_table_unref0 (directories);
		_g_object_unref0 (db);
		_g_object_unref0 (rec);
		return;
	}
	while (TRUE) {
		LibmsiQuery* _tmp95_;
		LibmsiRecord* _tmp96_ = NULL;
		LibmsiRecord* _tmp97_;
		LibmsiRecord* _tmp98_;
		LibmsiRecord* _tmp99_;
		gchar* _tmp100_ = NULL;
		gchar* cab;
		LibmsiDatabase* _tmp101_;
		const gchar* _tmp102_;
		GHashTable* _tmp103_;
		_tmp95_ = query;
		_tmp96_ = libmsi_query_fetch (_tmp95_, &_inner_error_);
		_tmp97_ = _tmp96_;
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			_g_hash_table_unref0 (cab_to_name);
			_g_hash_table_unref0 (components_dir);
			_g_object_unref0 (query);
			_g_hash_table_unref0 (directories);
			_g_object_unref0 (db);
			_g_object_unref0 (rec);
			return;
		}
		_g_object_unref0 (rec);
		rec = _tmp97_;
		_tmp98_ = rec;
		if (!(_tmp98_ != NULL)) {
			break;
		}
		_tmp99_ = rec;
		_tmp100_ = libmsi_record_get_string (_tmp99_, (guint) 4);
		cab = _tmp100_;
		_tmp101_ = db;
		_tmp102_ = cab;
		_tmp103_ = cab_to_name;
		extract_cab (_tmp101_, _tmp102_, _tmp103_, &_inner_error_);
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (cab);
			_g_hash_table_unref0 (cab_to_name);
			_g_hash_table_unref0 (components_dir);
			_g_object_unref0 (query);
			_g_hash_table_unref0 (directories);
			_g_object_unref0 (db);
			_g_object_unref0 (rec);
			return;
		}
		_g_free0 (cab);
	}
	_g_hash_table_unref0 (cab_to_name);
	_g_hash_table_unref0 (components_dir);
	_g_object_unref0 (query);
	_g_hash_table_unref0 (directories);
	_g_object_unref0 (db);
	_g_object_unref0 (rec);
}


gint _vala_main (gchar** args, int args_length1) {
	gint result = 0;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gchar* parameter_string;
	const gchar* _tmp2_;
	GOptionContext* _tmp3_;
	GOptionContext* opt_context;
	GOptionContext* _tmp4_;
	GOptionContext* _tmp5_;
	gboolean _tmp13_;
	gchar** _tmp15_;
	gint _tmp15__length1;
	const gchar* _tmp18_;
	GError * _inner_error_ = NULL;
	bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);
	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
	textdomain (GETTEXT_PACKAGE);
	g_set_application_name ("msiextract");
	_tmp0_ = _ ("- a msi files extracting tool");
	_tmp1_ = g_strdup (_tmp0_);
	parameter_string = _tmp1_;
	_tmp2_ = parameter_string;
	_tmp3_ = g_option_context_new (_tmp2_);
	opt_context = _tmp3_;
	_tmp4_ = opt_context;
	g_option_context_set_help_enabled (_tmp4_, TRUE);
	_tmp5_ = opt_context;
	g_option_context_add_main_entries (_tmp5_, options, NULL);
	{
		GOptionContext* _tmp6_;
		_tmp6_ = opt_context;
		g_option_context_parse (_tmp6_, &args_length1, &args, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (g_error_matches (_inner_error_, G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE)) {
				goto __catch0_g_option_error_bad_value;
			}
			if (_inner_error_->domain == G_OPTION_ERROR) {
				goto __catch0_g_option_error;
			}
			_g_option_context_free0 (opt_context);
			_g_free0 (parameter_string);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return 0;
		}
	}
	goto __finally0;
	__catch0_g_option_error_bad_value:
	{
		GError* err = NULL;
		FILE* _tmp7_;
		GOptionContext* _tmp8_;
		gchar* _tmp9_ = NULL;
		gchar* _tmp10_;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp7_ = stdout;
		_tmp8_ = opt_context;
		_tmp9_ = g_option_context_get_help (_tmp8_, TRUE, NULL);
		_tmp10_ = _tmp9_;
		fprintf (_tmp7_, "%s", _tmp10_);
		_g_free0 (_tmp10_);
		exit (1);
		_g_error_free0 (err);
	}
	goto __finally0;
	__catch0_g_option_error:
	{
		GError* _error_ = NULL;
		GError* _tmp11_;
		const gchar* _tmp12_;
		_error_ = _inner_error_;
		_inner_error_ = NULL;
		_tmp11_ = _error_;
		_tmp12_ = _tmp11_->message;
		g_warning ("msiextract.vala:137: %s", _tmp12_);
		_g_error_free0 (_error_);
	}
	__finally0:
	if (_inner_error_ != NULL) {
		_g_option_context_free0 (opt_context);
		_g_free0 (parameter_string);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	_tmp13_ = version;
	if (_tmp13_) {
		FILE* _tmp14_;
		_tmp14_ = stdout;
		fprintf (_tmp14_, "%s\n", PACKAGE_VERSION);
		exit (0);
	}
	_tmp15_ = files;
	_tmp15__length1 = _vala_array_length (files);
	if (_tmp15__length1 < 1) {
		FILE* _tmp16_;
		const gchar* _tmp17_ = NULL;
		_tmp16_ = stderr;
		_tmp17_ = _ ("Please specify input files.\n");
		fprintf (_tmp16_, "%s", _tmp17_);
		exit (1);
	}
	_tmp18_ = directory;
	if (_tmp18_ == NULL) {
		gchar* _tmp19_ = NULL;
		_tmp19_ = g_get_current_dir ();
		_g_free0 (directory);
		directory = _tmp19_;
	}
	{
		gchar** _tmp20_;
		gint _tmp20__length1;
		_tmp20_ = files;
		_tmp20__length1 = _vala_array_length (files);
		{
			gchar** file_collection = NULL;
			gint file_collection_length1 = 0;
			gint _file_collection_size_ = 0;
			gint file_it = 0;
			file_collection = _tmp20_;
			file_collection_length1 = _tmp20__length1;
			for (file_it = 0; file_it < _tmp20__length1; file_it = file_it + 1) {
				gchar* _tmp21_;
				gchar* file = NULL;
				_tmp21_ = g_strdup (file_collection[file_it]);
				file = _tmp21_;
				{
					const gchar* _tmp22_;
					_tmp22_ = file;
					extract (_tmp22_, &_inner_error_);
					if (_inner_error_ != NULL) {
						_g_free0 (file);
						goto __catch1_g_error;
					}
					_g_free0 (file);
				}
			}
		}
	}
	goto __finally1;
	__catch1_g_error:
	{
		GError* _error_ = NULL;
		FILE* _tmp23_;
		GError* _tmp24_;
		const gchar* _tmp25_;
		_error_ = _inner_error_;
		_inner_error_ = NULL;
		_tmp23_ = stderr;
		_tmp24_ = _error_;
		_tmp25_ = _tmp24_->message;
		fprintf (_tmp23_, "%s", _tmp25_);
		exit (1);
		_g_error_free0 (_error_);
	}
	__finally1:
	if (_inner_error_ != NULL) {
		_g_option_context_free0 (opt_context);
		_g_free0 (parameter_string);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	result = 0;
	_g_option_context_free0 (opt_context);
	_g_free0 (parameter_string);
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return _vala_main (argv, argc);
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



